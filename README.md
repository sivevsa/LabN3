# LabN3
## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнила: `Трофимова Виктория Алексеевна`

#### Вариант: `26`

### Cодержание:
- [Постановка задачи](#1-постановка-задачи)
- [Выбор структуры данных](#2-выбор-структуры-данных)
- [Алгоритм](#3-алгоритм)
- [Программа](#4-программа)
- [Анализ правильности решения](#5-анализ-правильности-решения)
- ### 1. Постановка задачи
- Краткое описание:
Разработать программу для моделирования поведения клавиатуры с ломающимися
клавишами. Реализовать функции управления состоянием клавиш (исправны или сломаны), проверки возможности ввода символов и слов, а также анализа текста для выявления неисправных клавиш.
Описание функционала
1. Вывод сломанных клавиш
Выводит список всех сломанных клавиш через запятую. Включает буквы, цифры
и клавишу SHIFT, если она сломана.
2. Сломать клавишу
Устанавливает переданную клавишу в состояние «сломана». Клавиша передаётся
символом.
3. Проверка возможности напечатать символ
Определяет, можно ли напечатать переданный символ, учитывая состояние клавиш.
4. Восстановление клавиши
Восстанавливает работоспособность переданной клавиши.
5. Проверка возможности напечатать слово
Проверяет, можно ли напечатать переданное слово с текущим состоянием клавиш.
6. Проверка сломанных букв
Определяет, сломана ли хотя бы одна буква из алфавита.
7. Проверка всех цифр
Определяет, сломаны ли все клавиши с цифрами.
8. Необходимые клавиши для слова
Возвращает список клавиш, которые необходимо восстановить для печати переданного слова. Если слово можно напечатать, возвращает null.
9. Печатаемые слова из строки
Определяет количество слов из переданной строки, которые можно напечатать с
текущим состоянием клавиш.
10. Анализ напечатанного слова
Принимает слово и его напечатанную версию. Обновляет состояние клавиш: - Помечает соответствующие клавиши как сломанные, если символ отсутствует в напечатанной версии; - Восстанавливает клавиши, если символ присутствует.
11. Восстановление или поломка строки
(Опционально) Восстанавливает или ломает клавиши, указанные в переданной
строке. Эта задача требует простого обновления состояния каждой клавиши, указанной в строке.
### 2. Выбор структуры данных
1. Массивы
- Массив mass — это массив типа boolean, где каждый элемент представляет собой состояние клавиши. Если элемент равен true, это означает, что соответствующая клавиша работает; если false, то клавиша сломана.
- Размер массива: Массив имеет фиксированный размер, который равен общей сумме количества латинских букв (26), русских букв (33), цифр (10) и клавиши SHIFT.
- Массив используется для:
  - Хранения информации о состоянии каждой клавиши.
  - Индексации клавиш по их позиции, что позволяет эффективно получать информацию о состоянии каждой клавиши.
2. Целочисленные переменные
- indShift — целочисленная переменная для хранения индекса клавиши SHIFT в массиве mass.
- aL, aR, digit — целочисленные переменные, которые хранят количество латинских и русских букв и цифр соответственно.
3. Логические значения (boolean)
Для представления состояния клавиш, используется массив типа boolean. Это идеальный выбор, так как состояние клавиши либо рабочее (true), либо сломано (false).
### 3. Алгоритм
#### Анализ алгоритма:
Всего в моей работе 3 класса:
1. **KeyboardState** отслеживает, работают ли клавиши. Информация о каждой клавише хранится в массиве mass. Класс позволяет проверить состояние клавиш, а также сломать или восстановить их.
2. **KeyboardOperations** выполняет более сложные действия с клавишами через объект KeyboardState. Например, класс может проверить, можно ли напечатать символ или слово. Он также анализирует уже напечатанные слова, подсчитывает количество слов в строке и восстанавливает или ломает клавиши.
3. **KeyboardTest** показывает, как использовать классы KeyboardState и KeyboardOperations. В этом классе проверяют всю функциональность: поломку клавиш, возможность печати и анализ напечатанных слов.
### Для чего нужны несколько классов:
- **Класс KeyboardState** служит для управления состоянием клавиш (отвечает за логику сломанных и исправных клавиш).
- **Класс KeyboardOperations** — это класс, который содержит правила для работы с состоянием клавиш. Он помогает понять, можно ли напечатать определённый символ или слово, а также анализирует введённый текст.
- **Класс KeyboardTest** используется для тестирования функционала и демонстрации работы программы.
Программа работает лучше, когда её разделили на части. В данном случае одна часть программы отслеживает состояние клавиш, а другая выполняет более сложные действия с ними.
#### Описание каждого класса:
#### Класс KeyboardState
###### Поля класса:
- mass — массив типа boolean, где каждый элемент отвечает за состояние клавиши на клавиатуре.
- aL — количество латинских букв (26).
- aR — количество русских букв (33).
- digit — количество цифр (10).
- indShift — индекс клавиши SHIFT в массиве.

###### Конструктор:
- KeyboardState() — конструктор по умолчанию, который инициализирует массив mass размером, равным сумме латинских букв, русских букв и цифр, и заполняет его значением true, что означает, что все клавиши работают.

###### Методы:
1. getBrokenKeys() — метод для получения списка сломанных клавиш, проверяет массив mass и выводит те клавиши, которые не работают.
2. getKeyIndex(char key) — метод для получения индекса клавиши в массиве mass на основе символа.
3. breakKey(char key) — метод для поломки клавиши; устанавливает ее состояние в false.
4. restoreKey(char key) — метод для восстановления клавиши; устанавливает ее состояние в true.
5. isKeyWorking(char key) — метод для проверки, работает ли клавиша (состояние true в массиве mass).

#### Класс KeyboardOperations
###### Поля класса:
- state — объект типа KeyboardState, который хранит состояние клавиш на клавиатуре.

###### Конструктор:
- KeyboardOperations(KeyboardState state) — конструктор, принимающий объект KeyboardState и использующий его для выполнения операций с клавишами.
###### Методы:
1. canTypeChar(char key) — метод для проверки, можно ли напечатать символ с учетом состояния клавиш.
2. canTypeWord(String word) — метод для проверки, можно ли напечатать слово, проверяя все его символы.
3. areAnyLettersBroken() — метод для проверки, есть ли хотя бы одна сломанная клавиша среди букв.
4. areAllDigitsBroken() — метод для проверки, все ли цифры сломаны.
5. necessaryKeysForWord(String word) — метод для получения списка необходимых клавиш для печати слова, которые нельзя напечатать из-за сломанных клавиш.
6. countPrintableWords(String text) — метод для подсчета количества печатаемых слов в строке, проверяя, можно ли напечатать каждое слово.
7. analyzeTypedWord(String word, String typedVersion) — метод для анализа напечатанного слова и обновления состояния клавиш.
8. toggleKeysForString(String keys) — метод для переключения состояния клавиш для строки, т.е. поломать клавиши, которые работают, и восстановить те, которые сломаны.
 #### Класс KeyboardTest
Этот класс содержит метод main, который используется для тестирования функционала клавиатуры, предоставляемого классами KeyboardState и KeyboardOperations.
### 4. Программа 
```java
// Класс для хранения состояния клавиш на клавиатуре
class KeyboardState {
    private int aL = 26;  // Латинский алфавит (a-z), 26 букв
    private int aR = 33;  // Русский алфавит (а-я), 33 буквы
    private int digit = 10;  // Цифры (0-9), 10 цифр
    private int indShift = aL + aR + digit; // Индекс для клавиши SHIFT
    private boolean[] mass = new boolean[aL + aR + digit + 1];  // Массив состояния клавиш (каждый элемент true, если клавиша исправна)

    // Конструктор, где все клавиши исправны
    public KeyboardState() {
        for (int i = 0; i < mass.length; i++) {
            mass[i] = true;  // Инициализация всех клавиш как исправных
        }
    }

    // 1. Метод для вывода сломанных клавиш
    public String getBrokenKeys() {
        String result = "";  // Строка для хранения сломанных клавиш
        // Проверяем все латинские буквы
        for (char c = 'a'; c <= 'z'; c++) {
            int index = c - 'a';  // Индекс латинской буквы
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем букву в строку результата
            }
        }
        // Проверяем все русские буквы
        for (char c = 'а'; c <= 'я'; c++) {
            int index = aL + (c - 'а');  // Индекс русской буквы
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем букву в строку результата
            }
        }
        // Проверяем все цифры
        for (char c = '0'; c <= '9'; c++) {
            int index = aL + aR + (c - '0');  // Индекс цифры
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем цифру в строку результата
            }
        }
        // Проверка клавиши SHIFT
        if (!mass[indShift]) {
            result += "SHIFT, ";  // Добавляем "SHIFT" в строку результата, если клавиша сломана
        }
        // Убираем последнюю запятую и пробел, если они есть
        if (result.length() > 0) {
            result = result.substring(0, result.length() - 2);  // Удаляем последнюю запятую и пробел
        } else {
            result = "Нет сломанных клавиш";  // Если нет сломанных клавиш
        }
        return result;  // Возвращаем строку с результатом
    }

    // Метод для получения индекса клавиши
    public int getKeyIndex(char key) {
        int n = -1;  // Изначально символ неверный (не найден)
        if (key >= 'a' && key <= 'z') {
            n = key - 'a';  // Индекс латинской буквы (от 0 до 25)
        } else if (key >= 'а' && key <= 'я') {
            n = aL + (key - 'а');  // Индекс русской буквы (от 26 до 58)
        } else if (key >= '0' && key <= '9') {
            n = aL + aR + (key - '0');  // Индекс цифры (от 59 до 68)
        } else if (key == '@') {
            n = indShift;  // Индекс для клавиши SHIFT
        }
        return n;  // Возвращаем индекс клавиши
    }

    // 2. Метод для поломки клавиши
    public void breakKey(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        if (index != -1) {  // Если клавиша существует
            mass[index] = false;  // Меняем состояние клавиши на "сломана"
        }
    }

    // 4. Метод для восстановления клавиши
    public void restoreKey(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        if (index != -1) {  // Если клавиша существует
            mass[index] = true;  // Меняем состояние клавиши на "исправна"
        }
    }

    // Метод для получения состояния клавиши (работает или нет)
    public boolean isKeyWorking(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        return index != -1 && mass[index];  // Возвращаем состояние клавиши: true, если исправна
    }
}

// Класс для выполнения операций с клавишами
class KeyboardOperations {
    private KeyboardState state;  // Ссылка на объект KeyboardState

    // Конструктор принимает объект KeyboardState
    public KeyboardOperations(KeyboardState state) {
        this.state = state;  // Инициализация объекта state
    }
    // 3. Метод для проверки возможности напечатать символ
    public boolean canTypeChar(char key) {
        // Проверяем, можно ли напечатать заглавную латинскую букву
        if (key >= 'A' && key <= 'Z') {
            if (!state.isKeyWorking('@')) {  // Если клавиша SHIFT сломана
                return false;  // Заглавные буквы не напечатаются
            }
            char lowerKey = (char) (key - 'A' + 'a');  // Преобразуем заглавную букву в строчную
            return state.isKeyWorking(lowerKey);  // Проверяем состояние строчной буквы
        }
        // Проверяем, можно ли напечатать заглавную русскую букву
        else if (key >= 'А' && key <= 'Я') {
            if (!state.isKeyWorking('@')) {  // Если клавиша SHIFT сломана
                return false;  // Заглавные русские буквы не напечатаются
            }
            char lowerKey = (char) (key - 'А' + 'а');  // Преобразуем заглавную русскую букву в строчную
            return state.isKeyWorking(lowerKey);  // Проверяем состояние строчной буквы
        }
        return state.isKeyWorking(key);  // Для остальных символов
    }

    // 5. Метод для проверки возможности напечатать слово
    public boolean canTypeWord(String word) {
        boolean n = true;  // Предполагаем, что слово можно напечатать
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);  // Извлекаем символ из слова
            if (!canTypeChar(c)) {  // Если хотя бы один символ нельзя напечатать
                n = false;  // Устанавливаем n в false
                break;  // Прерываем цикл, так как дальнейшая проверка не имеет смысла
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 6. Метод для проверки сломанных букв
    public boolean areAnyLettersBroken() {
        boolean n = false;  // Все буквы в рабочем состоянии
        // Проверка всех латинских букв
        for (char c = 'a'; c <= 'z'; c++) {
            if (!state.isKeyWorking(c)) {
                n = true;  // Если хотя бы одна клавиша сломана, устанавливаем n в true
            }
        }
        // Проверка всех русских букв
        for (char c = 'а'; c <= 'я'; c++) {
            if (!state.isKeyWorking(c)) {
                n = true;  // Если хотя бы одна клавиша сломана, устанавливаем n в true
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 7. Метод для проверки, сломаны ли все цифры
    public boolean areAllDigitsBroken() {
        boolean n = true;  // Предполагаем, что все цифры сломаны
        for (char c = '0'; c <= '9'; c++) {
            if (state.isKeyWorking(c)) {
                n = false;  // Если хотя бы одна цифра исправна, устанавливаем n в false
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 8. Метод для определения необходимых клавиш для слова
    public String necessaryKeysForWord(String word) {
        // Переменная для подсчета нужных клавиш
        int neededCount = 0;
        // Перебираем каждый символ в слове
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            // Если символ нельзя напечатать, увеличиваем счетчик
            if (!canTypeChar(c)) {
                neededCount++;
            }
        }
        // Если нет символов, которые нельзя напечатать, возвращаем null
        if (neededCount == 0) {
            return null;
        }
        // Строка для хранения символов, которые нельзя напечатать
        String result = " ";
        int index = 0;
        // Заполняем строку символами, которые нельзя напечатать
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (!canTypeChar(c)) {
                result += c + " ";  // Добавляем символ в строку результата
                index++;
            }
        }
        return result;  // Возвращаем строку с символами, которые нельзя напечатать
    }
    // 9. Метод для подсчета печатаемых слов в строке
    public int countPrintableWords(String text) {
        int wordCount = 0;  // Счётчик печатаемых слов
        int i = 0;

        while (i < text.length()) {
            while (i < text.length() && text.charAt(i) == ' ') {
                i++;  // Пропускаем пробелы
            }
            if (i < text.length()) {
                int start = i;
                while (i < text.length() && text.charAt(i) != ' ') {
                    i++;  // Читаем символы слова
                }
                String word = text.substring(start, i);  // Извлекаем слово
                if (canTypeWord(word)) {
                    wordCount++;  // Если слово можно напечатать, увеличиваем счётчик
                }
            }
        }
        return wordCount;  // Возвращаем количество печатаемых слов
    }

    // 10. Метод для анализа напечатанного слова
    public void analyzeTypedWord(String word, String typedVersion) {
        int wordIndex = 0;
        int typedIndex = 0;

        // Проходим по символам и сравниваем оригинальное слово с напечатанным
        while (wordIndex < word.length() && typedIndex < typedVersion.length()) {
            char originalChar = word.charAt(wordIndex);
            char typedChar = typedVersion.charAt(typedIndex);
            if (originalChar == typedChar) {
                state.restoreKey(originalChar);  // Если символ совпадает, восстанавливаем клавишу
                wordIndex++;
                typedIndex++;
            } else {
                state.breakKey(originalChar);  // Если символ не совпадает, ломаем клавишу
                wordIndex++;
            }
        }

        // Обработка оставшихся символов в слове
        while (wordIndex < word.length()) {
            char originalChar = word.charAt(wordIndex);
            state.breakKey(originalChar);  // Ломаем клавишу
            wordIndex++;
        }
    }

    // 11. Метод для переключения состояния клавиш строки
    public void toggleKeysForString(String keys) {
        for (int i = 0; i < keys.length(); i++) {
            char key = keys.charAt(i);
            if (canTypeChar(key)) {
                state.breakKey(key);  // Если можно напечатать символ, ломаем клавишу
            } else {
                state.restoreKey(key);  // Иначе восстанавливаем клавишу
            }
        }
    }
}

// Класс для тестирования функционала клавиатуры
class KeyboardTest {
    public static void main(String[] args) {
        KeyboardState keyboard = new KeyboardState();  // Создаём объект для состояния клавиш
        KeyboardOperations analyzer = new KeyboardOperations(keyboard);  // Создаём объект для операций с клавишами
        // Пример тестирования
        keyboard.breakKey('б');
        keyboard.breakKey('4');
        keyboard.breakKey('d');
        System.out.println("Сломанные клавиши: " + keyboard.getBrokenKeys());  // Проверка сломанных клавиш
        keyboard.restoreKey('4');
        keyboard.restoreKey('б');
        System.out.println("Сломанные клавиши после восстановления 4 и б: " + keyboard.getBrokenKeys());  // Проверка после восстановления

        // Пример проверки возможности напечатать символ
        System.out.println("Можно напечатать 'a'?: " + analyzer.canTypeChar('a'));

        // Пример проверки возможности напечатать слово
        System.out.println("Можно напечатать слово 'hello': " + analyzer.canTypeWord("hello"));

        // Пример анализа напечатанного слова
        analyzer.analyzeTypedWord("hello", "hll");
        System.out.println("Сломанные клавиши после анализа: " + keyboard.getBrokenKeys());

        // Пример подсчета печатаемых слов в строке
        System.out.println("Количество печатаемых слов: " + analyzer.countPrintableWords("do мама привет"));
        System.out.println("Необходимые буквы для слова 'do': " + analyzer.necessaryKeysForWord("do"));
        System.out.println("Есть сломанные буквы?: " + analyzer.areAnyLettersBroken());
        System.out.println("Все цифры сломаны?: " + analyzer.areAllDigitsBroken());
        analyzer.toggleKeysForString("do123");
        System.out.println("Сломанные клавиши после переключения: " + keyboard.getBrokenKeys());
    }
}
```
### 5. Анализ правильности решения
Все проверки взаимосвязаны между собой (данные, введенные в определнной проверке учитываются для следующих)
Общие данные:
```
KeyboardState keyboard = new KeyboardState();
KeyboardOperations analyzer = new KeyboardOperations(keyboard);
```
1. Проверим работу 2 задачи (сломаем клавиши)

    - **Input**:
        ```
        keyboard.breakKey('б');
        keyboard.breakKey('4');
        keyboard.breakKey('d');
        ```

    - **Output**:
        ```
        Сломанные клавиши: d, б, 4
        ```
2. Проверим работу 1  задачи (выведем сломанные клавиши)

    - **Input**:
        ```
        System.out.println("Сломанные клавиши: " + keyboard.getBrokenKeys());
        ```

    - **Output**:
        ```
        Сломанные клавиши: d, б, 4
        ```
3. Проверим работу 3 задачи (проверка возможности напечатать символ)

    - **Input**:
        ```
        System.out.println("Можно напечатать 'a'?: " + analyzer.canTypeChar('a'));
        ```

    - **Output**:
        ```
        Можно напечатать 'a'?: true
        ```
4. Проверим работу 4 задачи(восстановление клавиши) 

    - **Input**:
        ```
        keyboard.restoreKey('4');
        keyboard.restoreKey('б');
        System.out.println("Сломанные клавиши после восстановление 4 и б: " + keyboard.getBrokenKeys());
        ```

    - **Output**:
        ```
        Сломанные клавиши после восстановления 4 и б: d
        ```
  
5. Проверим работу 5 задачи (проверка возможности напечатать слово)

    - **Input**:
        ```
        System.out.println("Можно напечатать слово 'hello': " + analyzer.canTypeWord("hello"));
        ```

    - **Output**:
        ```
        Можно напечатать слово 'hello': true
        ```
6. Проверим работу 6 задачи (проверка сломанных букв)

    - **Input**:
        ```
        System.out.println("Есть сломанные буквы?: " + analyzer.areAnyLettersBroken());
        ```

    - **Output**:
        ```
        Есть сломанные буквы?: true
        ```
7. Проверим работу 7 задачи (проверка всех цифр)

    - **Input**:
        ```
        System.out.println("Все цифры сломаны?: " + analyzer.areAllDigitsBroken());
        ```

    - **Output**:
        ```
       Все цифры сломаны?: false
        ```
8. Проверим работу 8 задачи (необходимые клавиши для слова)

    - **Input**:
        ```
        System.out.println("Необходимые буквы для слова 'do': " + analyzer.necessaryKeysForWord("do"));
        ```

    - **Output**:
        ```
        Необходимые буквы для слова 'do':  d
        ```
9. Проверим работу 9 задачи (печатаемые слова из строки)

    - **Input**:
        ```
        System.out.println("Количество печатаемых слов: " + analyzer.countPrintableWords("do мама привет"));
        ```

    - **Output**:
        ```
        Количество печатаемых слов: 2
        ```
10. Проверим работу 10 задачи (анализ напечатанного слова)

    - **Input**:
        ```
        analyzer.analyzeTypedWord("hello", "hll");
        System.out.println("Сломанные клавиши после анализа: " + keyboard.getBrokenKeys());
        ```

    - **Output**:
        ```
        Сломанные клавиши после анализа: d, e, o
        ```
11. Проверим работу 11 задачи (восстановление или поломка строки)

    - **Input**:
        ```
        analyzer.toggleKeysForString("do123");
        System.out.println("Сломанные клавиши после переключения: " + keyboard.getBrokenKeys());
        ```

    - **Output**:
        ```
        Сломанные клавиши после переключения: e, 1, 2, 3
        ```
12. Проверим работу клавиши SHIFT(сломана)

    - **Input**:
        ```
        keyboard.breakKey('@');
        System.out.println("Можно напечатать слово 'HI': " + analyzer.canTypeWord("HI"));
        ```

    - **Output**:
        ```
        Можно напечатать слово 'HI': false
        ```
13. Проверим работу клавиши SHIFT(работает)

    - **Input**:
        ```
        keyboard.restoreKey('@');
        System.out.println("Можно напечатать слово 'HI': " + analyzer.canTypeWord("HI"));
        ```

    - **Output**:
        ```
        Можно напечатать слово 'HI': true
        ```
