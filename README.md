# LabN3
## Отчет по лабораторной работе № 3

#### № группы: `ПМ-2402`

#### Выполнила: `Стадникова Диана Денисовна`

#### Вариант: `24`

### Cодержание:
- [Постановка задачи](#1-постановка-задачи)
- [Алгоритм](#2-алгоритм)
- [Программа](#3-программа)
- [Анализ правильности решения](#4-анализ-правильности-решения)
- ### 1. Постановка задачи
- Краткое описание
Разработать программу для моделирования поведения клавиатуры с ломающимися
клавишами. Реализовать функции управления состоянием клавиш (исправны или сломаны), проверки возможности ввода символов и слов, а также анализа текста для выявления неисправных клавиш.
Описание функционала
1. Вывод сломанных клавиш
Выводит список всех сломанных клавиш через запятую. Включает буквы, цифры
и клавишу SHIFT, если она сломана.
2. Сломать клавишу
Устанавливает переданную клавишу в состояние «сломана». Клавиша передаётся
символом.
3. Проверка возможности напечатать символ
Определяет, можно ли напечатать переданный символ, учитывая состояние клавиш.
4. Восстановление клавиши
Восстанавливает работоспособность переданной клавиши.
5. Проверка возможности напечатать слово
Проверяет, можно ли напечатать переданное слово с текущим состоянием клавиш.
6. Проверка сломанных букв
Определяет, сломана ли хотя бы одна буква из алфавита.
7. Проверка всех цифр
Определяет, сломаны ли все клавиши с цифрами.
8. Необходимые клавиши для слова
Возвращает список клавиш, которые необходимо восстановить для печати переданного слова. Если слово можно напечатать, возвращает null.
9. Печатаемые слова из строки
Определяет количество слов из переданной строки, которые можно напечатать с
текущим состоянием клавиш.
10. Анализ напечатанного слова
Принимает слово и его напечатанную версию. Обновляет состояние клавиш: - Помечает соответствующие клавиши как сломанные, если символ отсутствует в напечатанной версии; - Восстанавливает клавиши, если символ присутствует.
11. Восстановление или поломка строки
(Опционально) Восстанавливает или ломает клавиши, указанные в переданной
строке. Эта задача требует простого обновления состояния каждой клавиши, указанной в строке.
### 2. Алгоритм
#### Анализ алгоритма:
Всего в моей работе 3 класса:
1. **KeyboardState** управляет состоянием клавиш. Каждая клавиша может быть сломана или исправна, и это состояние хранится в массиве mass. Класс предоставляет методы для поломки и восстановления клавиш, а также для проверки их состояния.
2. **KeyboardOperations** работает с клавишами через объект KeyboardState, предоставляя более высокоуровневые операции, такие как проверка возможности напечатать символ или слово. Также этот класс анализирует уже напечатанные слова, восстанавливая или ломая клавиши, а также подсчитывает количество печатаемых слов в строке.
3. **KeyboardTest** демонстрирует использование классов KeyboardState и KeyboardOperations. В этом классе тестируется вся функциональность, включая поломку клавиш, проверку возможности печати и анализ напечатанных слов.
### Для чего нужны несколько классов:
- **Класс KeyboardState** служит для управления состоянием клавиш (отвечает за логику сломанных и исправных клавиш).
- **Класс KeyboardOperations** инкапсулирует логику, которая работает с состоянием клавиш, предоставляя функционал для проверки, можно ли напечатать символы и слова, а также анализа ввода текста.
- **Класс KeyboardTest** используется для тестирования функционала и демонстрации работы программы.
Таким образом, разделение на несколько классов позволяет улучшить структуру программы, разделяя ответственность за управление состоянием клавиш и за более высокоуровневые операции с ними.
#### Описание каждого класса:
### Класс KeyboardState

Этот класс отвечает за состояние клавиш на клавиатуре. Он управляет массивом состояний клавиш, где каждая клавиша может быть либо исправной (true), либо сломанной (false). 

- Переменные:
  - aL, aR, digit: Константы, представляющие количество символов для латинского алфавита, русского алфавита и цифр, соответственно.
  - indShift: Индекс для клавиши SHIFT.
  - mass: Массив типа boolean, который отслеживает состояние каждой клавиши. Размер массива — это сумма всех символов латинского алфавита, русского алфавита, цифр и клавиши SHIFT.
  
- Методы:
  - getBrokenKeys(): Возвращает строку с перечнем сломанных клавиш (латинских букв, русских букв, цифр и SHIFT).
  - getKeyIndex(char key): Возвращает индекс клавиши в массиве mass в зависимости от её символа (латинская буква, русская буква, цифра или SHIFT).
  - breakKey(char key): Помечает клавишу как сломанную (меняет её состояние на false).
  - restoreKey(char key): Восстанавливает клавишу (меняет её состояние на true).
  - isKeyWorking(char key): Проверяет, работает ли клавиша (возвращает true, если клавиша исправна).

### Класс KeyboardOperations

Этот класс управляет операциями с клавишами на основе состояния клавиатуры, предоставляемого объектом KeyboardState. Основная цель — проверка, можно ли напечатать тот или иной символ, слово, или подсчёт количества печатаемых слов в строке.

- Переменная:
  - state: Объект класса KeyboardState, который хранит состояние клавиш.
  
- Методы:
  - canTypeChar(char key): Проверяет, можно ли напечатать символ, в том числе учитывая, работает ли клавиша SHIFT для заглавных букв.
  - canTypeWord(String word): Проверяет, можно ли напечатать слово. Если хотя бы один символ не может быть напечатан, возвращает false.
  - areAnyLettersBroken(): Проверяет, есть ли сломанные буквы в латинском или русском алфавите.
  - areAllDigitsBroken(): Проверяет, сломаны ли все цифры.
  - necessaryKeysForWord(String word): Возвращает строку с символами, которые необходимы для печати слова, но не могут быть напечатаны из-за сломанных клавиш.
  - countPrintableWords(String text): Подсчитывает количество печатаемых слов в строке (при этом слова должны быть возможны для набора на клавиатуре).
  - analyzeTypedWord(String word, String typedVersion): Анализирует напечатанное слово, сравнивая его с оригинальным, и соответственно ломает или восстанавливает клавиши.
  - toggleKeysForString(String keys): Меняет состояние клавиш для заданной строки (ломает работающие клавиши и восстанавливает сломанные).

### Класс KeyboardTest
Этот класс содержит метод main, который используется для тестирования функционала клавиатуры, предоставляемого классами KeyboardState и KeyboardOperations.
- В нём:
  - Демонстрируется процесс поломки и восстановления клавиш.
  - Проверяется возможность напечатать символы и слова.
  - Анализируется состояние клавиш после ввода текста.
  - Проводится подсчёт печатаемых слов и проверка, какие клавиши необходимы для ввода слов.
### 3. Программа 
```java
// Класс для хранения состояния клавиш на клавиатуре
class KeyboardState {
    private int aL = 26;  // Латинский алфавит (a-z), 26 букв
    private int aR = 33;  // Русский алфавит (а-я), 33 буквы
    private int digit = 10;  // Цифры (0-9), 10 цифр
    private int indShift = aL + aR + digit; // Индекс для клавиши SHIFT
    private boolean[] mass = new boolean[aL + aR + digit + 1];  // Массив состояния клавиш (каждый элемент true, если клавиша исправна)

    // Конструктор, где все клавиши исправны
    public KeyboardState() {
        for (int i = 0; i < mass.length; i++) {
            mass[i] = true;  // Инициализация всех клавиш как исправных
        }
    }

    // 1. Метод для вывода сломанных клавиш
    public String getBrokenKeys() {
        String result = "";  // Строка для хранения сломанных клавиш
        // Проверяем все латинские буквы
        for (char c = 'a'; c <= 'z'; c++) {
            int index = c - 'a';  // Индекс латинской буквы
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем букву в строку результата
            }
        }
        // Проверяем все русские буквы
        for (char c = 'а'; c <= 'я'; c++) {
            int index = aL + (c - 'а');  // Индекс русской буквы
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем букву в строку результата
            }
        }
        // Проверяем все цифры
        for (char c = '0'; c <= '9'; c++) {
            int index = aL + aR + (c - '0');  // Индекс цифры
            if (!mass[index]) {  // Если клавиша сломана
                result += c + ", ";  // Добавляем цифру в строку результата
            }
        }
        // Проверка клавиши SHIFT
        if (!mass[indShift]) {
            result += "SHIFT, ";  // Добавляем "SHIFT" в строку результата, если клавиша сломана
        }
        // Убираем последнюю запятую и пробел, если они есть
        if (result.length() > 0) {
            result = result.substring(0, result.length() - 2);  // Удаляем последнюю запятую и пробел
        } else {
            result = "Нет сломанных клавиш";  // Если нет сломанных клавиш
        }
        return result;  // Возвращаем строку с результатом
    }

    // Метод для получения индекса клавиши
    public int getKeyIndex(char key) {
        int n = -1;  // Изначально символ неверный (не найден)
        if (key >= 'a' && key <= 'z') {
            n = key - 'a';  // Индекс латинской буквы (от 0 до 25)
        } else if (key >= 'а' && key <= 'я') {
            n = aL + (key - 'а');  // Индекс русской буквы (от 26 до 58)
        } else if (key >= '0' && key <= '9') {
            n = aL + aR + (key - '0');  // Индекс цифры (от 59 до 68)
        } else if (key == '@') {
            n = indShift;  // Индекс для клавиши SHIFT
        }
        return n;  // Возвращаем индекс клавиши
    }

    // 2. Метод для поломки клавиши
    public void breakKey(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        if (index != -1) {  // Если клавиша существует
            mass[index] = false;  // Меняем состояние клавиши на "сломана"
        }
    }

    // 4. Метод для восстановления клавиши
    public void restoreKey(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        if (index != -1) {  // Если клавиша существует
            mass[index] = true;  // Меняем состояние клавиши на "исправна"
        }
    }

    // Метод для получения состояния клавиши (работает или нет)
    public boolean isKeyWorking(char key) {
        int index = getKeyIndex(key);  // Получаем индекс клавиши
        return index != -1 && mass[index];  // Возвращаем состояние клавиши: true, если исправна
    }
}

// Класс для выполнения операций с клавишами
class KeyboardOperations {
    private KeyboardState state;  // Ссылка на объект KeyboardState

    // Конструктор принимает объект KeyboardState
    public KeyboardOperations(KeyboardState state) {
        this.state = state;  // Инициализация объекта state
    }
    // 3. Метод для проверки возможности напечатать символ
    public boolean canTypeChar(char key) {
        int index = state.getKeyIndex(key);  // Получаем индекс клавиши
        // Проверяем, можно ли напечатать заглавную латинскую букву
        if (key >= 'A' && key <= 'Z') {
            if (!state.isKeyWorking('@')) {  // Если клавиша SHIFT сломана
                return false;  // Заглавные буквы не напечатаются
            }
            char lowerKey = (char) (key - 'A' + 'a');  // Преобразуем заглавную букву в строчную
            return state.isKeyWorking(lowerKey);  // Проверяем состояние строчной буквы
        }
        // Проверяем, можно ли напечатать заглавную русскую букву
        else if (key >= 'А' && key <= 'Я') {
            if (!state.isKeyWorking('@')) {  // Если клавиша SHIFT сломана
                return false;  // Заглавные русские буквы не напечатаются
            }
            char lowerKey = (char) (key - 'А' + 'а');  // Преобразуем заглавную русскую букву в строчную
            return state.isKeyWorking(lowerKey);  // Проверяем состояние строчной буквы
        }
        return state.isKeyWorking(key);  // Для остальных символов
    }

    // 5. Метод для проверки возможности напечатать слово
    public boolean canTypeWord(String word) {
        boolean n = true;  // Предполагаем, что слово можно напечатать
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);  // Извлекаем символ из слова
            if (!canTypeChar(c)) {  // Если хотя бы один символ нельзя напечатать
                n = false;  // Устанавливаем n в false
                break;  // Прерываем цикл, так как дальнейшая проверка не имеет смысла
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 6. Метод для проверки сломанных букв
    public boolean areAnyLettersBroken() {
        boolean n = false;  // Все буквы в рабочем состоянии
        // Проверка всех латинских букв
        for (char c = 'a'; c <= 'z'; c++) {
            if (!state.isKeyWorking(c)) {
                n = true;  // Если хотя бы одна клавиша сломана, устанавливаем n в true
            }
        }
        // Проверка всех русских букв
        for (char c = 'а'; c <= 'я'; c++) {
            if (!state.isKeyWorking(c)) {
                n = true;  // Если хотя бы одна клавиша сломана, устанавливаем n в true
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 7. Метод для проверки, сломаны ли все цифры
    public boolean areAllDigitsBroken() {
        boolean n = true;  // Предполагаем, что все цифры сломаны
        for (char c = '0'; c <= '9'; c++) {
            if (state.isKeyWorking(c)) {
                n = false;  // Если хотя бы одна цифра исправна, устанавливаем n в false
            }
        }
        return n;  // Возвращаем значение переменной n
    }

    // 8. Метод для определения необходимых клавиш для слова
    public String necessaryKeysForWord(String word) {
        // Переменная для подсчета нужных клавиш
        int neededCount = 0;
        // Перебираем каждый символ в слове
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            // Если символ нельзя напечатать, увеличиваем счетчик
            if (!canTypeChar(c)) {
                neededCount++;
            }
        }
        // Если нет символов, которые нельзя напечатать, возвращаем null
        if (neededCount == 0) {
            return null;
        }
        // Строка для хранения символов, которые нельзя напечатать
        String result = " ";
        int index = 0;
        // Заполняем строку символами, которые нельзя напечатать
        for (int i = 0; i < word.length(); i++) {
            char c = word.charAt(i);
            if (!canTypeChar(c)) {
                result += c + " ";  // Добавляем символ в строку результата
                index++;
            }
        }
        return result;  // Возвращаем строку с символами, которые нельзя напечатать
    }
    // 9. Метод для подсчета печатаемых слов в строке
    public int countPrintableWords(String text) {
        int wordCount = 0;  // Счётчик печатаемых слов
        int i = 0;

        while (i < text.length()) {
            while (i < text.length() && text.charAt(i) == ' ') {
                i++;  // Пропускаем пробелы
            }
            if (i < text.length()) {
                int start = i;
                while (i < text.length() && text.charAt(i) != ' ') {
                    i++;  // Читаем символы слова
                }
                String word = text.substring(start, i);  // Извлекаем слово
                if (canTypeWord(word)) {
                    wordCount++;  // Если слово можно напечатать, увеличиваем счётчик
                }
            }
        }
        return wordCount;  // Возвращаем количество печатаемых слов
    }

    // 10. Метод для анализа напечатанного слова
    public void analyzeTypedWord(String word, String typedVersion) {
        int wordIndex = 0;
        int typedIndex = 0;

        // Проходим по символам и сравниваем оригинальное слово с напечатанным
        while (wordIndex < word.length() && typedIndex < typedVersion.length()) {
            char originalChar = word.charAt(wordIndex);
            char typedChar = typedVersion.charAt(typedIndex);
            if (originalChar == typedChar) {
                state.restoreKey(originalChar);  // Если символ совпадает, восстанавливаем клавишу
                wordIndex++;
                typedIndex++;
            } else {
                state.breakKey(originalChar);  // Если символ не совпадает, ломаем клавишу
                wordIndex++;
            }
        }

        // Обработка оставшихся символов в слове
        while (wordIndex < word.length()) {
            char originalChar = word.charAt(wordIndex);
            state.breakKey(originalChar);  // Ломаем клавишу
            wordIndex++;
        }
    }

    // 11. Метод для переключения состояния клавиш строки
    public void toggleKeysForString(String keys) {
        for (int i = 0; i < keys.length(); i++) {
            char key = keys.charAt(i);
            if (canTypeChar(key)) {
                state.breakKey(key);  // Если можно напечатать символ, ломаем клавишу
            } else {
                state.restoreKey(key);  // Иначе восстанавливаем клавишу
            }
        }
    }
}

// Класс для тестирования функционала клавиатуры
class KeyboardTest {
    public static void main(String[] args) {
        KeyboardState keyboard = new KeyboardState();  // Создаём объект для состояния клавиш
        KeyboardOperations analyzer = new KeyboardOperations(keyboard);  // Создаём объект для операций с клавишами

        // Пример тестирования
        keyboard.breakKey('a');
        System.out.println("Сломанные клавиши: " + keyboard.getBrokenKeys());  // Проверка сломанных клавиш
        keyboard.restoreKey('a');
        System.out.println("Сломанные клавиши после восстановление a: " + keyboard.getBrokenKeys());  // Проверка после восстановления

        // Пример проверки возможности напечатать символ
        System.out.println("Можно напечатать 'a': " + analyzer.canTypeChar('a'));

        // Пример проверки возможности напечатать слово
        System.out.println("Можно напечатать слово 'hello': " + analyzer.canTypeWord("hello"));

        // Пример анализа напечатанного слова
        analyzer.analyzeTypedWord("hello", "hll");
        System.out.println("Сломанные клавиши после анализа: " + keyboard.getBrokenKeys());

        // Пример подсчета печатаемых слов в строке
        System.out.println("Количество печатаемых слов: " + analyzer.countPrintableWords("hello world Вика Класс"));
        analyzer.toggleKeysForString("vkn");
        System.out.println("Сломанные клавиши после переключения: " + keyboard.getBrokenKeys());
        KeyboardState state = new KeyboardState();
        KeyboardOperations key = new KeyboardOperations(keyboard);
        keyboard.breakKey('g');
        System.out.println(key.necessaryKeysForWord("gvfj456"));
    }
}
```
### 4. Анализ правильности решения
